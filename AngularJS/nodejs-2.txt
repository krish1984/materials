What is a module in NodeJS:
A module encapsulates related code into a single unit of code. When creating a module, this can be interpreted as moving all related functions into a file.

exports & module.exports
------------------------
is a way to allow importing other files in ur node program. In browsers, we simply refer the dependencies before referring the actual program. So the functions,variables,classes defined in the
library are automatically visible&accessible in you file. But Nodejs defines a clean approch for this, in order to structure your program into different files.
node.js provides you with a simple module system.

You can refer a particualr js using: requires("./utils.js") and the utils.js must expose the what all it wants to expose using a exports or module.exports.
The exported unit can be a variable, function, class..etc.

Ex: 
utils.js:
------
module.exports = ['Lemmy Kilmister', 'Ozzy Osbourne', 'Ronnie James Dio', 'Steven Tyler', 'Mick Jagger'];
exports.name = function() {
    console.log('hello...');
};
in ur app:
------------
var rocker = require('./utils.js');
console.log('Rockin in heaven: ' + rocker[2]);
rocker.name();

rocker.js
-----------
module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +' is '+ this.age +' years old');
    };
};
in ur app:
----------------
var Rocker = require('./rocker.js');
var r = new Rocker('Ozzy', 62);
r.about();


Difference between exports & module.exports:
------------------------------------
With module.exports u can assign only 1 value to it.It is used when you want to expose one variable. It could be a function, string, or any valid variable.

module.exports = function() {
  return 'bread: 2';
};
module.exports.age = "2 days";

var bread = require ('./bread.js');
console.log(bread());
console.log(bread.age); //will not work

In a nutshell:
--------------------------
You can do something like:

module.exports = {
    method: function() {},
    otherMethod: function() {}
}
Or even just:

exports.method = function() {};
exports.otherMethod = function() {};

app.use(app.router);
------------------------------------------

router is code that runs your routes. When you do app.get('/user', function(req, res) { ... });, it is the router that actually invokes the callback function 
to process the request.

The order that you pass things to app.use determines the order in which each middleware is given the opportunity to process a request. 
For example, if you have a file called test.html in your static folder and a route:

app.get('/test.html', function(req, res) {
    res.send('Hello from route handler');
});
Which one gets sent to a client requesting http://server/test.html? Whichever middleware is given to use first.

If you do this:
app.use(express.static(__dirname + '/public'));
app.use(app.router);
Then the file on disk is served. If you do it the other way,

app.use(app.router);
app.use(express.static(__dirname + '/public')); Then the route handler gets the request, and "Hello from route handler" gets sent to the browser.

Usually, you want to put the router above the static middleware so that a accidentally-named file can't override one of your routes.

Note that if you don't explicitly use the router, it is implicitly added by Express at the point you define a route (which is why your routes still worked even though you commented out app.use(app.router)).


Using middleware
----------------------------
An Express application is essentially a series of middleware function calls. Middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.

Middleware functions can perform the following tasks:

Execute any code.
Make changes to the request and the response objects.
End the request-response cycle.
Call the next middleware function in the stack.
If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.

An Express application can use the following types of middleware:

Application-level middleware
Router-level middleware
Error-handling middleware
Built-in middleware
Third-party middleware

Application-level middleware
Bind application-level middleware to an instance of the app object by using the app.use().This example shows a middleware function with no mount path. The function is executed every time the app receives a request.

var app = express()
app.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})
This example shows a middleware function mounted on the /user/:id path. The function is executed for any type of HTTP request on the /user/:id path.

app.use('/user/:id', function (req, res, next) {
  console.log('Request Type:', req.method)
  next()
})

You can also chain middlewares as follows:
app.use('/user/:id', function (req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}, function (req, res, next) {
  console.log('Request Type:', req.method)
  next()
})

Router-level middleware
Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of express.Router().

var app = express()
var router = express.Router()
// a middleware function with no mount path. This code is executed for every request to the router
router.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})

// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
router.use('/user/:id', function (req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}, function (req, res, next) {
  console.log('Request Type:', req.method)
  next()
})

// a middleware sub-stack that handles GET requests to the /user/:id path
router.get('/user/:id', function (req, res, next) {
  // if the user ID is 0, skip to the next router
  if (req.params.id === '0') next('route')
  // otherwise pass control to the next middleware function in this stack
  else next()
}, function (req, res, next) {
  // render a regular page
  res.render('regular')
})

// handler for the /user/:id path, which renders a special page
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id)
  res.render('special')
})

// mount the router on the app
app.use('/', router)

Error-handling middleware
Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors.

app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})

Built-in middleware
The only built-in middleware function in Express is express.static.
You can have more than one static directory per app:

app.use(express.static('public'))
app.use(express.static('uploads'))
app.use(express.static('files'))

Third-party middleware
Use third-party middleware to add functionality to Express apps.
var express = require('express')
var app = express()
var cookieParser = require('cookie-parser')
// load the cookie-parsing middleware
app.use(cookieParser())
