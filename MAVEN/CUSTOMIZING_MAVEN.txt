import (only available in Maven 2.0.9 or later)
This scope is only used on a dependency of type pom in the <dependencyManagement> section. It indicates that the specified POM should be replaced with 
the dependencies in that POM's <dependencyManagement> section. Since they are replaced, dependencies with a scope of import do not actually participate in 
limiting the transitivity of a dependency.

For jar type artifact, the default o/p folder is target/classes right? Can we change that to something like "war/WEB-INF/classes"?
If we do that, will the jar generated will also be under "war/WEB-INF/classes"???
Yes,
Yes,  just add the following in POM.xml:
<build>
	<outputDirectory>war/WEB-INF/classes</outputDirectory>
</build>

No, it will be in the target/classes(jar plugin just copies the files from outputDirectory).

How to include java source code in the jar file generated by maven?
Genearlly, resource plugin (called just before compile) looks for a tag called resources in your pom, copies files specified by Resource elements, 
to an output directory (incase of jar, it is target/classes). By default, resource plugin has config: <resource><directory>src/main/resources</directory>. i.e All 
files from resources folder are only copied. If you want it to copy sources also, you can override the resources tag to specify that as follows:
<build>
		<resources>
			<resource>
				<directory>src/main/resources</directory>
				<includes>
					<include>**/*.txt</include>
					<include>**/*.jpeg</include>
				</includes>
				<excludes>
					<exclude>**/*test*.*</exclude>
				</excludes>
				<filtering>true</filtering>---> with out this, *test* files are not filtered.
			</resource>
			<resource>
				<directory>src/main/java</directory> --- > to copy the source code also in to the target/classes, which will be later packaged by package plugin.
			</resource>
		</resources>
</build>

With the above code, 
1. all of our .java files and any files under resources are copied to target/classes (process-resources)
2. then compiler plugin will compile the src files to the same directpry. (compile)
3. package plugin will jar the target/classes (package)
4. install plugin will take this and copy to local repo.
5. deploy plugin will take this and upload to remote repository.

If you type, mvn help:describe -Dcmd=process-resources, you will see that resources:resources goal is bounded to that phase "process-resources".
The resources plugin also has 2 other goals:
resources:testResources: Bounded to the process-test-resources phase, copies the resources for the test source code to the test output directory.
resources:copy-resources: copies resources to an output directory. Not bound to any phase bydefault, You have to configure the resources to be copied, and specify the outputDirectory.
<plugin>
        <artifactId>maven-resources-plugin</artifactId>
        <version>3.0.2</version>
        <executions>
          <execution>
            <id>my_id</id>
            <phase>validate</phase>
            <goals>
              <goal>copy-resources</goal>
            </goals>
            <configuration>
              <outputDirectory>${basedir}/target/extra-resources</outputDirectory>
              <resources>          
                <resource>
                  <directory>src/non-packaged-resources</directory>
                  <filtering>true</filtering>
                </resource>
              </resources>              
            </configuration>            
          </execution>
        </executions>
      </plugin>
	  
How can i generate additional attached jar artifacts from the project ? In otherwords, Can we generate different output files/jars from a maven build?
Yes. 
Ex:
abc-project
|-- pom.xml
|-- src\
`-- target
    `-- abc-project-1.0-SNAPSHOT.jar
    `-- abc-project-1.0-SNAPSHOT-javadoc.jar
    `-- abc-project-1.0-SNAPSHOT-sources.jar

The following code generates the -sources.jar.   

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-source-plugin</artifactId>--->binds with package phase byefault.
  <executions>
    <execution>
      <id>attach-sources</id>
      <goals>
        <goal>jar</goal>
      </goals>
    </execution>
  </executions>
</plugin>

The following code generates the -javadoc.jar.   

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-javadoc-plugin</artifactId>--->binds with package phase byefault.
  <executions>
    <execution>
      <id>attach-javadocs</id>
      <goals>
        <goal>jar</goal>
      </goals>
    </execution>
  </executions>
</plugin>

Yet another example, 
<plugin>
	<artifactId>maven-jar-plugin</artifactId>
	<version>2.4</version>
	<executions>
		<execution>
			<id>default-jar</id>
			<phase>package</phase>
			<goals>
				<goal>jar</goal>
			</goals>
			<configuration>
				<classifier>client</classifier>
				<includes>
					<include>**/*service*.*</include>
				</includes>
				<filters>true</filters>
			</configuration>
		</execution>
	</executions>
</plugin>

This execution id "<id>default-jar</id>" is the id we have in super pom. we copied the plugin from super pom and pasted it and adding config to it.
So it is nothing but we r overriding the defualt functionality. The op will be only 1 file: hello-0.0.1-SNAPSHOT-client.jar which contains only */*service*.* files.
If you want to untouch regular jar being generated + additional jar along with the jar generated by super pom, just define another execution with different id
as follows:
<plugin>
	<artifactId>maven-jar-plugin</artifactId>
	<version>2.4</version>
	<executions>
		<execution>
			<id>default-jar</id>
			<phase>package</phase>
			<goals>
				<goal>jar</goal>
			</goals>
		</execution>
		<execution>
			<id>default-jar-1</id>
			<phase>package</phase>
			<goals>
				<goal>jar</goal>
			</goals>
			<configuration>
				<classifier>client</classifier>
				<includes>
					<include>**/*service*.*</include>
				</includes>
				<filters>true</filters>
			</configuration>
		</execution>
	</executions>
</plugin>
									  
Classifier
We have seen that a build can generate multiple output jars. When a client project uses it, how can it choose and pick the specific output file that it wants? 
The classifier allows to distinguish artifacts that were built from the same POM but differ in their content. It is some optional and arbitrary 
string that - if present - is appended to the artifact name just after the version number. 
As a motivation for this element, consider for example a project that offers an artifact targeting JRE 1.5 but at the same time also an artifact that still 
supports JRE 1.4. The first artifact could be equipped with the classifier jdk15 and the second one with jdk14 such that clients can choose which one to use.  
e.g.: For testng following is the dependency [corresponding jar is testng-5.8-jdk15] 
<dependency>
    <groupId>org.testng</groupId>
    <artifactId>testng</artifactId>
    <version>5.8</version>
    <type>jar</type>
    <classifier>jdk15</classifier>
    <scope>compile</scope>
</dependency>
Another common use case for classifiers is the need to attach secondary artifacts to the project's main artifact. If you browse the Maven central repository, 
you will notice that the classifiers sources and javadoc are used to deploy the project source code and API docs along with the packaged class files. 


Maven Assembly
-------------------------
Till now we have seen verious capabilities of maven: It can generate jar/war/ear files based on the build type, it can even generate different output files (artifacts) with different contents from the same 
build..etc. But how about generating a zip file, tar.gz file with our custom layout some thing like below:
C:.
+---hello-0.0.1-SNAPSHOT
    ¦
    +---docs
	|    |--index.html
	|
	|---userguide
	|     |----index.html
	|
    +---images
    +---lib
    ¦    hello-0.0.1-SNAPSHOT.jar
    ¦
    +---licenses
    |        LICENSE.txt
	|--README.txt	

It is possible with maven assembly plugin..
Ex: 

<plugin>
	<artifactId>maven-assembly-plugin</artifactId>
	<configuration>
		<descriptors>
			<descriptor>assembly.xml</descriptor>
		</descriptors>
	</configuration>
	<executions>
		<execution>
			<id>zip</id>
			<phase>package</phase>
			<goals>
				<goal>single</goal>
			</goals>
		</execution>
	</executions>
</plugin>	

project_root/assembly.xml
---------------------------
<assembly>
  <id>bin</id>
  <formats>
    <format>tar.gz</format>  -- creates hello-0.0.1-SNAPSHOT-bin.tar
    <format>zip</format> -- -- creates hello-0.0.1-SNAPSHOT-bin.zip
  </formats>
  <fileSets>
    <fileSet>
      <directory>${project.basedir}</directory>
      <outputDirectory>/text_docs</outputDirectory>
      <includes>
        <include>README*</include>
        <include>LICENSE*</include>
        <include>NOTICE*</include>
      </includes>
    </fileSet>
    <fileSet>
    <directory>src/bin</directory>
    <outputDirectory>bin</outputDirectory>
    <includes>
      <include>*.bat</include>
    </includes>
    <lineEnding>dos</lineEnding>
  </fileSet>
    <fileSet>
      <directory>${project.build.directory}</directory>
      <outputDirectory>/lib</outputDirectory>
      <includes>
        <include>*.jar</include>
      </includes>
    </fileSet>
    <fileSet>
      <directory>${project.build.directory}/site</directory>
      <outputDirectory>docs</outputDirectory>
    </fileSet>
  </fileSets>
</assembly>

If your requirement to generate output file is in one of the layouts that maven already offers, then we dont need to create an assembly.xml. We can just 
reuse the assembly layout templates that the plugin already offers as follows:
<configuration>
	<descriptorRefs>
		<descriptorRef>bin</descriptorRef>
	</descriptorRefs>
</configuration>
There are four predefined descriptor formats available for reuse, packaged within the Assembly Plugin. 
Their descriptorIds are: bin,jar-with-dependencies,src,project More on this: https://maven.apache.org/plugins/maven-assembly-plugin/descriptor-refs.html

In v3, the frontend project uses the following code to generate its artifact:
<plugin>
	<artifactId>maven-assembly-plugin</artifactId>
	<version>${mvnAssembly.version}</version>
	<configuration>
		<descriptors>
			<descriptor>assembly.xml</descriptor>
		</descriptors>
	</configuration>
	<executions>
		<execution>
			<id>zip</id>
			<phase>package</phase>
			<goals>
				<goal>single</goal>
			</goals>
		</execution>
	</executions>
</plugin>
					
Customizing the the format & location of dependency
----------------------------------------------------------
The assembly plugin we have see above, can create jar with all dependencies in it. What if we want to accept a dependency in a differnt format(.zip) than its 
original(jar) and place other than classpath.

<profile>
	<id>nofrontend</id>
	<build>
	<plugins>
<plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-dependency-plugin</artifactId>
	<executions>
		<execution>
			<id>copy</id>
			<phase>package</phase>
			<goals>
				<goal>copy</goal>
			</goals>
			<configuration>
				<artifactItems>
					<artifactItem>
						<groupId>com.vitechinc.v3.gwt</groupId>
						<artifactId>frontend</artifactId>
						<version>${project.version}</version>
						<type>zip</type>
						<classifier>bin</classifier>
						<overWrite>true</overWrite>
						<outputDirectory>${basedir}/frontend/target</outputDirectory>--> This downloads the dependency from artifact repository and puts it in the target. 
						<destFileName>Frontend-bin.zip</destFileName>
					</artifactItem>
				</artifactItems>
			</configuration>
		</execution>
	</executions>
</plugin>
</plugins>
</build>

The 

v310-uc-client.pom.xml
------------------------
The v310-uc client project uses the following code to copy its dependency frontend-bin.zip the root of its build outputDirectory:
 <plugin>
	<groupId>org.apache.maven.plugins</groupId>
	<artifactId>maven-dependency-plugin</artifactId>
	<executions>
	<execution>
            <id>explodefrontend</id>
            <phase>prepare-package</phase>
            <goals>
              <goal>unpack</goal>
            </goals>   
            <configuration>
              <artifactItems>
                <artifactItem>                 
                  <groupId>com.vitechinc.v3.gwt</groupId>
                  <artifactId>frontend</artifactId>
                  <type>zip</type>
                  <classifier>bin</classifier>
                  <outputDirectory>${project.build.directory}/${project.build.finalName}</outputDirectory>
                </artifactItem>
              </artifactItems>
            </configuration>                                             
          </execution>
	</executions>
</plugin>
     
Yet another example:
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-dependency-plugin</artifactId>  
   <executions>  
	<execution>
	  <!--  Copy the ckeditor bundle in as a resource before packaging starts. -->
	  <id>ExplodeCKEditor</id>
	  <phase>prepare-package</phase>
	  <goals>
		<goal>unpack-dependencies</goal>
	  </goals>
	  <configuration>
		<includeGroupIds>com.ckeditor</includeGroupIds>
		<includeArtifactIds>ckeditor</includeArtifactIds>
		<outputDirectory>src/main/webapp/resources</outputDirectory>
	  </configuration>
	</execution>
	<execution>
		<!-- explode Snowbound Image Viewer -->
		<id>ExplodeSnowbound</id>
		<phase>prepare-package</phase>
		<goals>
			<goal>unpack-dependencies</goal>
		</goals>   
		<configuration>
			<includeGroupIds>com.vitechinc.v3</includeGroupIds>
			<includeArtifactIds>${snowbound.artifactid}</includeArtifactIds>
			<outputDirectory>src/main/webapp</outputDirectory>
			<excludes>META-INF/**</excludes>
		</configuration>                                             
	</execution>
	<execution>
		<!-- Explode web.xml and error pages-->
		<id>ExplodeWebXml</id>
		<phase>prepare-package</phase>
		<goals>
			<goal>unpack-dependencies</goal>
		</goals>   
		<configuration>
			<includeGroupIds>com.vitechinc.v3</includeGroupIds>
			<includeArtifactIds>V3WebMeta</includeArtifactIds>
			<outputDirectory>src/main/webapp/WEB-INF</outputDirectory>
			<includes>
				**\/web.xml,                    	
				**\/error/*
			</includes>
		</configuration>                                             
	</execution>                
					
Maven eclipse plugin:
-----------------------
<plugin>
<groupId>org.apache.maven.plugins</groupId>
<artifactId>maven-eclipse-plugin</artifactId>
<version>2.9</version>
<configuration>
  <downloadSources>true</downloadSources>
  <downloadJavadocs>true</downloadJavadocs>
  <testSourcesLast>true</testSourcesLast>
  <projectnatures>
	  <projectnature>org.eclipse.jdt.core.javanature</projectnature>
	  <nature>com.google.gwt.eclipse.core.gwtNature</nature>
  </projectnatures>
  <buildcommands>
	<buildcommand>org.eclipse.jdt.core.javabuilder</buildcommand>
	<buildcommand>com.google.gwt.eclipse.core.gwtProjectValidator</buildcommand>
  </buildcommands>
  <classpathContainers>
	<classpathContainer>org.eclipse.jdt.launching.JRE_CONTAINER</classpathContainer>
	<classpathContainer>com.google.gwt.eclipse.core.GWT_CONTAINER</classpathContainer>
  </classpathContainers>
</configuration>
</plugin>