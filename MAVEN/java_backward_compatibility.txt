The good thing about java is that, sources compiled with very low JDK versions (i.e in 90's) can run in the latest JDKs or JREs.
So your hardwork done before 10 years, can still generate funds to you by selling it to cusomers today. This oldest bytecode generated can 
still run in the newest JVMs.
We say that java bytecode is said to be forwards compatible where as the JRE/Java runtime is said to be backwards compatabile with older 
bytecode. we can also say that java compiler is  backwards compatabile. This feature of java is the selling point of java!


Java versions:
Target   Major.minor
1.1      45.3
1.2      46.0
1.3      47.0
1.4      48.0
5 (1.5)  49.0
6 (1.6)  50.0
7 (1.7)  51.0
8 (1.8)  52.0
9        53.0
To see the version of compiled class file use : javap -verbose Test | find "version", which will show you major.minor:

 minor version: 0
 major version: 46

 From the above, we can say that the class file version is 1.2. Other way is to open the class file in eclipse, which shows "Src not found" error and also displays the major.minor version!
 
 
Note that, compilers in JDK can compile the source to a specific lower version of JVM and when you take that class file and run it in lower 
JREs it works perfectly,This is known as backwards compatibility of java compiler.
For ex: JDK 1.8 can compile the source code, to any of lower JRE versions like 1.7,1.6,1.5,1.3, 1.2 and even 1.1. Because, JDK 1.8 contains 
compilers of all previous versions in it.When you say, source=1.4, it picks 1.4 compiler and tries to compile. As long as you dont use latest 
syntax like Generics, AutoBoxing..etc it will compile.


In maven Say, you are running Java 1.5 or 1.6 locally but need to deploy your app to a Java 1.4 production server. You could specify to compile to 
1.4 by setting a that JDK target and source as follows: 
				<configuration>
                   <source>1.4</source> -- > This is just passed as is to the actual java compiler with -source param.
                    <target>1.4</target> -- > This is just passed as is to the actual java compiler with -target param.
                </configuration>

source: Tells the version of the java compiler to use. must be equal or lower than target.
target: Tells the  compatible bytecode the compiler invoked above should generate. must be equal or grater than source.

The default for -target depends on the value of -source:

If -source is not specified, the value of -target is 1.6
If -source is 1.2, the value of -target is 1.4
If -source is 1.3, the value of -target is 1.4
For all other values of -source, the value of -target is the value of -source.

Note that target should be equal or greater than source. If you say source=1.8 target=1.5, You will get a build error:
javac: source release 1.8 requires target release 1.8. Why? You can not use latest compiler 1.8 to generate lower versions 
of classfiles 1.2. If you want to generate lower versions of classfiles,you can use lower of compiler only rite? 
It knows what syntax is allowed. i.e for ex: It will complain that generics are not supported, autoboxing not supported..etc.
If you use a higher version of java compiler, It can understand all the latest sytax but it can not generate the lower version of class file.
why?

Bytecode is versioned and JVM checks if it supports the version it finds in .class files.
Some language constructs cannot be expressed in previous versions of bytecode.
There are new classes and methods in newer JRE's which won't work with older ones.


Also, note that you can NOT compile to a higher JRE than the JDK you are using in maven. The source&target must be equal or lower to the JDK 
maven is using.Because, A older version of the JDK cannot compile with a more recent version since it doesn't know its specification.

Can we run a bytecode generated by latest java version in a lower JRE/runtime?
No, You will get Unsupported major.minor version 52.0 by JVM.