What maven offers you?
Dependency management:No more manual management of dependencies and guessing versions.Easier dependency management. just add a dependency, u r done!, maven will also download the sources if you say so.
Build standardization - “A Common Interface”
All basic functionality is provided no matter what Maven project you use. In case of ANT, you have to manually write everything from scrath.
Lifecycle management
Provides a build life cycle instead of making completely you build your own.
Project management best practices
Consistent directory structure provides easy understanding of artifacts 
Documentation: Maven generates documentation.
SCMs
Releases
Distribution

What are maven features:
1. Folows plugin architecture. Every minute task that maven does is by its plugins. You can customize maven fully by customizing these plugins.
You have full flexibility, for ex: you can tell maven at what phase a plugin should be invoked and what goal of the plugin needs to called at 
that phase...etc. Also, If needed you can disable a plugin altogether.
2.Convention over Configuration
Maven uses Convention over Configuration which means developers are not required to create build process themselves like in ANT.
3. Maven follows a plugin architecture, every phase is maven build lifecycle is implmented by a plugin. Thease plugins are 
completely customizable.
4. If still not satified maven allows you to invoke ant scripts also.

Developers do not have to mention each and every configuration detail  like in ANT. Maven provides sensible default behavior for projects. 
When a Maven project is created, Maven creates default project structure. Developer is only required to place files accordingly and 
he/she need not to define any configuration in pom.xml.

http://books.sonatype.com/mvnref-book/reference/lifecycle-sect-structure.html

Example maven project structure:
----------------------------
Item	        Default
source code	    ${basedir}/src/main/java
resources	    ${basedir}/src/main/resources
Tests	        ${basedir}/src/test
distributable JAR	${basedir}/target
Complied byte code	${basedir}/target/classes

Ok, now if i change the directory of src to xyz or put some of config files in src itself apart from resources,
how to handle that?
<build>
	    <sourceDirectory>src</sourceDirectory>
		<testSourceDirectory>test/java</testSourceDirectory>
		<resources>
			<resource>
				<directory>src</directory>
				<excludes>
					<exclude>**/*.java</exclude>
				</excludes>
			</resource>
			<resource>
				<directory>main/resources</directory>
			</resource>
		</resources>
</build>



Maven build life cycles & phases
------------------------------------
Maven are 3 built-in build lifecycles: default, clean and site. The default lifecycle handles your project deployment, 
the clean lifecycle handles project cleaning, while the site lifecycle handles the creation of your project's site documentation.
Each lifecycle is made up of build phases and each build Phase is Made Up of Plugin Goals.
A plugin goal represents a specific task (finer than a build phase) which contributes to the building of a project. It may be bound to 
zero or more build phases. if a goal is bound to one or more build phases, that goal will be called in all those phases.
A goal not bound to any build phase could be executed outside of the build lifecycle by direct invocation. 
The order of execution depends on the order in which the goal(s) and the build phase(s) are invoked. 
For example: mvn clean dependency:copy-dependencies package
clean phase is invoked 1st, then copy-dependencies goal of dependency plugin is onvoked, finally package goal.


Following are the build phases for each of the above lifecycles:

Clean lifecycle:
pre-clean	execute processes needed prior to the actual project cleaning
clean	remove all files generated by the previous build
post-clean	execute processes needed to finalize the project cleaning

Maven clean goal (clean:clean) is bound to the clean phase in the clean lifecycle. Its clean:clean goal deletes the output of a build 
by deleting the build directory. Thus when mvn clean command executes, Maven deletes the build directory.
We can customize this behavior by mentioning goals in any of the above phases of clean life cycle.
Ex:
<plugin>
   <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-antrun-plugin</artifactId>
   <version>1.1</version>
   <executions>
      <execution>
         <id>id.pre-clean</id>
         <phase>pre-clean</phase>
         <goals>
            <goal>run</goal>
         </goals>
         <configuration>
            <tasks>
               <echo>pre-clean phase</echo>
            </tasks>
         </configuration>
      </execution>
      <execution>
         <id>id.clean</id>
         <phase>clean</phase>
         <goals>
          <goal>run</goal>
         </goals>
         <configuration>
            <tasks>
               <echo>clean phase</echo>
            </tasks>
         </configuration>
      </execution>
      <execution>
         <id>id.post-clean</id>
         <phase>post-clean</phase>
         <goals>
            <goal>run</goal>
         </goals>
         <configuration>
            <tasks>
               <echo>post-clean phase</echo>
            </tasks>
         </configuration>
      </execution>
   </executions>
   </plugin>

Default (or Build) lifecycle:
validate	validate the project is correct and all necessary information is available.
initialize	initialize build state, e.g. set properties or create directories.
generate-sources	generate any source code for inclusion in compilation.
process-sources	process the source code, for example to filter any values.
generate-resources	generate resources for inclusion in the package.
process-resources	copy and process the resources into the destination directory, ready for packaging.
compile	compile the source code of the project.
process-classes	post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.
generate-test-sources	generate any test source code for inclusion in compilation.
process-test-sources	process the test source code, for example to filter any values.
generate-test-resources	create resources for testing.
process-test-resources	copy and process the resources into the test destination directory.
test-compile	compile the test source code into the test destination directory
process-test-classes	post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.
test	run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.
prepare-package	perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above)
package	take the compiled code and package it in its distributable format, such as a JAR.
pre-integration-test	perform actions required before integration tests are executed. This may involve things such as setting up the required environment.
integration-test	process and deploy the package if necessary into an environment where integration tests can be run.
post-integration-test	perform actions required after integration tests have been executed. This may including cleaning up the environment.
verify	run any checks to verify the package is valid and meets quality criteria.
install	install the package into the local repository, for use as a dependency in other projects locally.
deploy	done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.

There are few important concepts related to Maven Lifecycles which are worth to mention:

When a phase is called via Maven command, for example mvn compile, only phases upto and including that phase will execute.

Different maven goals will be bound to different phases of Maven lifecycle depending upon the type of packaging (JAR / WAR / EAR).

Site:
pre-site	execute processes needed prior to the actual project site generation
site	generate the project's site documentation
post-site	execute processes needed to finalize the site generation, and to prepare for site deployment
site-deploy	deploy the generated site documentation to the specified web server

The phases named with hyphenated-words (pre-*, post-*, or process-*) are not usually directly called from the command line.


Maven supported packaging types
-------------------------------------
Some of the valid packaging values are pom, jar, maven-plugin, ejb, war, ear, rar.If no packaging value has been specified, it will default to jar.

Each packaging contains a list of goals to bind to a particular phase. For example, the jar packaging will bind the following goals to build phases of the default lifecycle.

process-resources	resources:resources
compile	compiler:compile
process-test-resources	resources:testResources
test-compile	compiler:testCompile
test	surefire:test
package	jar:jar
install	install:install
deploy	deploy:deploy

If you want to see  all the info about a particular command, you can use: mvn help:describe -Dcmd=validate

mvn help:describe -Dcmd=clean: 
o/p:
[INFO] 'clean' is a lifecycle with the following phases:
* pre-clean: Not defined
* clean: org.apache.maven.plugins:maven-clean-plugin:2.4.1:clean
* post-clean: Not defined

mvn help:describe -Dcmd=install: 
o/p:
[INFO] --- maven-help-plugin:2.2:describe (default-cli) @ childs ---
[INFO] 'install' is a phase corresponding to this plugin:
org.apache.maven.plugins:maven-install-plugin:2.3.1:install
It is a part of the lifecycle for the POM packaging 'jar'. This lifecycle includes the following phases:
* validate: Not defined
* initialize: Not defined
* generate-sources: Not defined
* process-sources: Not defined
* generate-resources: Not defined
* process-resources: org.apache.maven.plugins:maven-resources-plugin:2.5:resources
* compile: org.apache.maven.plugins:maven-compiler-plugin:2.3.2:compile
* process-classes: Not defined
* generate-test-sources: Not defined
* process-test-sources: Not defined
* generate-test-resources: Not defined
* process-test-resources: org.apache.maven.plugins:maven-resources-plugin:2.5:testResources
* test-compile: org.apache.maven.plugins:maven-compiler-plugin:2.3.2:testCompile
* process-test-classes: Not defined
* test: org.apache.maven.plugins:maven-surefire-plugin:2.10:test
* prepare-package: Not defined
* package: org.apache.maven.plugins:maven-jar-plugin:2.3.2:jar
* pre-integration-test: Not defined
* integration-test: Not defined
* post-integration-test: Not defined
* verify: Not defined
* install: org.apache.maven.plugins:maven-install-plugin:2.3.1:install
* deploy: org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy

So, When you are saying 
mvn clean
mvn install
mvn package
mvn compile
mvn test, You are actually specifying the lifecycle/build phase/plugin goal and as per the definition of how goals are binded to phases for the specific packaging type, 
maven will simply invoke that particualr goal. So above commands are equal to:
mvn org.apache.maven.plugins:maven-clean-plugin:2.4.1:clean
mvn org.apache.maven.plugins:maven-install-plugin:2.3.1:install

mvn clean install: clean is a lifecycle, install is a phase.


Super POM:
----------------
The Super POM is Maven's default POM. All POMs extend the Super POM unless explicitly set, meaning the configuration specified in the Super POM is inherited 
by the POMs you created for your projects. 

<project>
  <modelVersion>4.0.0</modelVersion>
  <name>Maven Default Project</name>
 
  <repositories>
    <repository>
      <id>central</id>
      <name>Maven Repository Switchboard</name>
      <layout>default</layout>
      <url>http://repo1.maven.org/maven2</url>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
    </repository>
  </repositories>
 
  <pluginRepositories>
    <pluginRepository>
      <id>central</id>
      <name>Maven Plugin Repository</name>
      <url>http://repo1.maven.org/maven2</url>
      <layout>default</layout>
      <snapshots>
        <enabled>false</enabled>
      </snapshots>
      <releases>
        <updatePolicy>never</updatePolicy>
      </releases>
    </pluginRepository>
  </pluginRepositories>
 
  <build>
    <directory>${project.basedir}/target</directory>
    <outputDirectory>${project.build.directory}/classes</outputDirectory>
    <finalName>${project.artifactId}-${project.version}</finalName>
    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>
    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>
    <!-- TODO: MNG-3731 maven-plugin-tools-api < 2.4.4 expect this to be relative... -->
    <scriptSourceDirectory>src/main/scripts</scriptSourceDirectory>
    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>
    <resources>
      <resource>
        <directory>${project.basedir}/src/main/resources</directory>
      </resource>
    </resources>
    <testResources>
      <testResource>
        <directory>${project.basedir}/src/test/resources</directory>
      </testResource>
    </testResources>
   <pluginManagement>
       <plugins>
         <plugin>
           <artifactId>maven-antrun-plugin</artifactId>
           <version>1.3</version>
         </plugin>       
         <plugin>
           <artifactId>maven-assembly-plugin</artifactId>
           <version>2.2-beta-2</version>
         </plugin>         
         <plugin>
           <artifactId>maven-clean-plugin</artifactId>
           <version>2.2</version>
         </plugin>
         <plugin>
           <artifactId>maven-compiler-plugin</artifactId>
           <version>2.0.2</version>
         </plugin>
         <plugin>
           <artifactId>maven-dependency-plugin</artifactId>
           <version>2.0</version>
         </plugin>
         <plugin>
           <artifactId>maven-deploy-plugin</artifactId>
           <version>2.4</version>
         </plugin>
         <plugin>
           <artifactId>maven-ear-plugin</artifactId>
           <version>2.3.1</version>
         </plugin>
         <plugin>
           <artifactId>maven-ejb-plugin</artifactId>
           <version>2.1</version>
         </plugin>
         <plugin>
           <artifactId>maven-install-plugin</artifactId>
           <version>2.2</version>
         </plugin>
         <plugin>
           <artifactId>maven-jar-plugin</artifactId>
           <version>2.2</version>
         </plugin>
         <plugin>
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.5</version>
         </plugin>
         <plugin>
           <artifactId>maven-plugin-plugin</artifactId>
           <version>2.4.3</version>
         </plugin>
         <plugin>
           <artifactId>maven-rar-plugin</artifactId>
           <version>2.2</version>
         </plugin>        
         <plugin>                
           <artifactId>maven-release-plugin</artifactId>
           <version>2.0-beta-8</version>
         </plugin>
         <plugin>                
           <artifactId>maven-resources-plugin</artifactId>
           <version>2.3</version>
         </plugin>
         <plugin>
           <artifactId>maven-site-plugin</artifactId>
           <version>2.0-beta-7</version>
         </plugin>
         <plugin>
           <artifactId>maven-source-plugin</artifactId>
           <version>2.0.4</version>
         </plugin>         
         <plugin>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>2.4.3</version>
         </plugin>
         <plugin>
           <artifactId>maven-war-plugin</artifactId>
           <version>2.1-alpha-2</version>
         </plugin>
       </plugins>
     </pluginManagement>
  </build>
 
  <reporting>
    <outputDirectory>${project.build.directory}/site</outputDirectory>
  </reporting>
  <profiles>
    <profile>
      <id>release-profile</id>
 
      <activation>
        <property>
          <name>performRelease</name>
          <value>true</value>
        </property>
      </activation>
 
      <build>
        <plugins>
          <plugin>
            <inherited>true</inherited>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-source-plugin</artifactId>
            <executions>
              <execution>
                <id>attach-sources</id>
                <goals>
                  <goal>jar</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
          <plugin>
            <inherited>true</inherited>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-javadoc-plugin</artifactId>
            <executions>
              <execution>
                <id>attach-javadocs</id>
                <goals>
                  <goal>jar</goal>
                </goals>
              </execution>
            </executions>
          </plugin>
          <plugin>
            <inherited>true</inherited>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-deploy-plugin</artifactId>
            <configuration>
              <updateReleaseInfo>true</updateReleaseInfo>
            </configuration>
          </plugin>
        </plugins>
      </build>
    </profile>
  </profiles>
 
</project>

Project Inheritance
Elements in the POM that are merged are the following:

dependencies
developers and contributors
plugin lists (including reports)
plugin executions with matching ids
plugin configuration
resources

Dependencies:
--------------------

There r 2 ways to define a dependency:
1. using dependency tag
2. using dependencyManagement tag

The dependencyManagement tag is only valid iff the packaging="POM". Typically, a parent project of type POM defines a dependency using the
dependencyManagement to tell, declare a particular version for the dependency being defined, across all the child projects using this POM as parent.

In otherwords, it is just to centralize version numbers in the parent POM, Only declare the artifacts without version numbers in the child projects.Note that,
dependencyManagement tag will not add any dependency in the child projects. It is up to the child projects, whether or not to use them.

Managed Dependencies:
-----------------------
Till now we are adding any dependency into our projects, using a <dependency> tag. But what if our project has multiple modules and all modules need the same dependency? Do we go about adding the new dependency in all child projects? If the project grows it becomes very likely that such an artifact will be used by several modules. In most cases it’s not just a good idea but also necessary to make sure that the same version is used in all cases.

Maven therefore provides a mechanism to manage dependencies, i.e. to declare the version to be used for a specific artifact either in a 1. top level pom.xml file
2. or in a pom.xml file which acts as a BOM (bill of materials):
<project ...>
...
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>com.buschmais.jaxbfx</groupId>
        <artifactId>jaxbfx</artifactId>
        <version>1.1.0</version>
      </dependency>
    <dependencies>
  <dependencyManagement>
...
</project>
The dependency can now be referenced without the version, this information will be taken from the dependency management section:

<project...>
...
  <dependencies>
    <dependency>
      <groupId>com.buschmais.jaxbfx</groupId>
      <artifactId>jaxbfx</artifactId>
    </dependency>
  <dependencies>
...
</project>
There’s a further benefit of this approach: It becomes very easy to change the version of a required library even for large multi-module projects. To achieve this it’s necessary that all used dependencies are managed and no dependency with an explicit version is declared.

In a nutshell only those dependencies, declared using the dependencyManagement tag in the parent POM, are known as managed dependencies. When, child declares a 
diff version for the same dependency defined by dependencyManagement tag in its parent, then child POM gets warning saying that 
"Overriding managed version 3.2.2 for commons-collections"
Ex:

Parent:
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8</version>
    </dependency>
 </dependencies>
</dependencyManagement>

Child:
<dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
	  <version>3.2</version> ------------> This will give warning!
    </dependency>
 </dependencies>


Transitive Dependencies:
-------------------------
There are two types of Maven dependencies:
Direct: These are dependencies defined in your pom.xml file under the <dependencies/> section.
Transitive: These are dependencies that are dependencies of your direct dependencies.

In otherwords, Suppose our project called ourproj is dependent on a project called proj1(jar or proj) and suppose that proj1 has its own dependencies say commons-lang jar.
This means that ourproj is NOT just dependent on proj1 but it is also dependent on the commons-lang jar file. So when ourproj is built, Maven automatically adds 
both proj1 and its own dependency commons-lang jar to the classpath of  ourproj.The dependency commons-lang jar is called
as Transitive dependency.

If you go to the buildpath of ourproj in eclipse and see the jars/projects added in its classpath, u will see that all the dependencies of proj1 
are added in the classpath of ourproj along with proj1 itself. This is the default behavior.

Referring to dependency project instead of jar in eclipse:
-------------------------------------------------------------
So, now incase of eclipse: when importing the ourproj project using Import > Exisitng maven projects, eclipse will see if the project proj1
dependency is already in the workspace. If it finds one, then eclipse will refer to that project instead of its jar, so that we can see the sourcecode
of proj1 and make changes and see those changes reflected while working ourproj. Note that, eclipse can do this only if we are importing both 
proj1 and ourproj using Import > Exisitng maven projects feature, that too if we are importing dependencies 1st. If we are importing all projects
by selecting the root folder of all the projects in the workspace, then eclipse will take care of importing the dependencies 1st.

Now say if we close, delete project proj1 from workspace, then eclipse will update the classpath of ourproj to just refer to its jar file instead
of the proj directly. If we open/import proj1 again into workspace then, eclipse will again update ourproj's classpath to refer to the proj1 project 
directly by removing the jar dependency. Wow, how cool is that!

Note:
If we 1st do mvn eclipse:eclipse from cmd and then import the projects using the Import > General > Exisitng Projects into workspace, then 
this feature will not be available. This is due to the way maven eclipse plugin works. Most of the times, it may not be in sync with eclipse that you are using.

Note: that when a maven project is built even if it has dependencies that directly refer to the projects with in the workspace, 
the dependent project's builds are not automatically triggered. For that to happen, You need to define projects as modules instaed of seperate projects.


Optional dependencies: (Optional * exclusiion)
-------------------------
Optional dependencies are are mainly used to reduce the transitive burden of some libraries. For example: If you can use a library with 5 
different database types, but you usually only require one, you can mark the library's dependencies as optional, so that the user can 
supply the one he actually uses. If you don't do, you might get two types of problems:

The library pulls a huge load of transitive dependencies of which user actually need very few so that you blow up your project without 
reason.

More dangerously: You might pull two libraries with overlapping classes(urs & users).

Dependency Conflicts
----------------------------
Different libraries require diversion versions of the same dependency
By default:
The nearest dependency to the top wins.
The first dependency declared at a given level wins.
You can visualize conflicts in the Dependency Hierarchy view of eclipse pom.xml.
2 fixes available to fix conflicts:
Either Declare the correct version in your POM file or exclude the unwanted version explicitly.


Handling duplicate dependencies & exluding transitive dependencies
------------------------------------------------------------
when there are multiple dependencies with same groupid,atrifactid, Maven makes sure that only one version will be imported in your Project. 
For ex, if ourproj uses a dependency proj1 which uses common-lang-1.2 and ourproj also uses common-lang version 0.1, then maven takes our 
version 0.1.maven can do this only if the groupId and artifactId of the two are same, otherwise maven still copies both in the build output 
having the same pkg.class in two different jars and the classloader will endup taking the one which it picks first from the lib, which leads to
unexpected behaviors. Ex: JSR-211 & jax-rs-2 jars have the same clss called "javax.ws.rs.core.Response"
   	 
In such cases, you can exclude transitive dependency JSR-211 by using excludes as follows:
		<dependency>
			 <groupId>com.vitech.projects</groupId>
  			<artifactId>core</artifactId>
			<version>0.0.1-SNAPSHOT</version>
			<exclusions>
				<exclusion>
					<groupId>javax.ws.rs</groupId>
					<artifactId>jsr311-api</artifactId>
					<version>1.1.1</version>
				</exclusion>
			</exclusions>
		</dependency>
With the above code, u can happily use core library by excluding its dependency into our project.

Dependency scopes:
--------------------------
Dependency scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks.
When we are talking about dependency scopes, scope is w.r.t maven build, but not in eclipse. In eclipse, you always see that the dependency 
is in the classpath. If you open, dependency hierarhy in eclipse, you will note that all the libraries are in the classpath irrespective of the
scopes.
What this means is that, maven updates the classpath at each phase during the build.

compile
This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, 
those dependencies are propagated to dependent projects. It will be in the classpath starting from the compile phase to the final build output.
Examples: Hibernate, Spring, ...

provided
This is much like compile, but indicates you expect the JDK or a container(tomcat..etc) to provide the dependency at runtime. 
For example, when building a web application, you would set the dependency on the Servlet API and related Java EE APIs to scope provided 
because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.
It will be in the classpath only during compile phase. At runtime, the dependencies are picked from container.
Examples: Servlet API,wlfullclient.jar

runtime
Runtime Scope indicates that the dependency is available to your project on the unit test execution and runtime execution classpaths, but 
unlike compile scope it is not available when you compile your application or its unit tests. i.e if you refer a class from runtime dependency in ur code, eclipse does't give any error, but when you 
do mvn compile, you will see a compilation error.

A Runtime Dependency is copied into your deployed application, but it is not available during compilation! 
This is good for making sure you do not mistakenly depend on a specific library. If u want ur 3party jar to dynamically load and use
some impl during runtime, then you go for it.It also keeps the dependency from being transitive. So that, for example, if module A has a runtime dependency on library X, and module B depends on module A, 
it does not inherit the dependency on library X.
Ex: Oracle JDBC impl is not required for compilation, u use only the java spec in your code,also slf4j-impl is added as a runtime dependency, and Commons Logging will automatically discover this and uses it.

As you know when we build a maven project, third party jars are not compiled again. Jar once built is built, it will
not be compiled again and  a jar can be built only after successfull compilation. It can sometiems happen that we remove a class file from a 3rd party jar or 
jar itself may be currupted. In such cases, If another 3rd party jar calls the missing class in the 1st thirdpart jar, then we get classnotfounderrors.

test
This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation 
and execution phases. This scope is not transitive.
Examples: JUnit, TestNG, ...

system (Rarely used (better to use the repositories))
System Dependencies
A system dependency is available throught out the build lifecycle and also packaged in the final artficat. 
A system dependency is not looked up in repository, It is the responsibility of the dev to provide a systemPath that tells where it is available.
system dependencies are especially useful for resolving dependencies which are now provided by the JDK, but were available as separate downloads before.
Typical example are the JDBC standard extensions or the Java Authentication and Authorization Service (JAAS).
Ex:
<dependencies>
    <dependency>
      <groupId>javax.sql</groupId>
      <artifactId>jdbc-stdext</artifactId>
      <version>2.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/lib/rt.jar</systemPath>
    </dependency>
	<dependency>
      <groupId>sun.jdk</groupId>
      <artifactId>tools</artifactId>
      <version>1.5.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/../lib/tools.jar</systemPath>
    </dependency>
  </dependencies>

System scope was only designed to deal with 'system' files; files sitting in some fixed location. Files in /usr/lib, or ${java.home} 
(e.g. tools.jar). It wasn't designed to support miscellaneous .jar files in your project.better to use the repositories


import (only available in Maven 2.0.9 or later)
Can i add a dependency of type pom like any other jar dependency im my pom.xml ? in other words, How to use POMs as a dependency in Maven?
 Yes.
 But why you want to do that? Sayyou have 100 dependencies which are common acrros projects, then instead of declaring them in each project, you can put all of them in one
 pom and add that pom dependency to each project and selectively exclude unwanted dependency ine ach project.
 Ex:
 <project>
    <groupId>com.mycompany</groupId>
    <artifactId>mail-deps</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    <dependencies>
        <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>gimap</artifactId>
            <version>1.5.0</version>
        </dependency>
        <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>pop3</artifactId>
            <version>1.5.0</version>
        </dependency>
        <dependency>
            <groupId>com.sun.mail</groupId>
            <artifactId>dsn</artifactId>
            <version>1.5.0</version>
        </dependency>
    </dependencies>
</project>

Then in your original project just add:

<dependencies>
    <dependency>
        <groupId>com.mycompany</groupId>
        <artifactId>mail-deps</artifactId>
        <version>1.0.0</version>
        <type>pom</type> -------------------> what will be the default scope here? Seeing the effective POM, it is "COMPILE".
    </dependency>
</dependencies>

Note that only dependencies, dependencyManagement, pluginManagement sections in the given POM is taken. Others like properties..etc are not taken. 
If you want that also to happen, u need to add the "mail-deps" pom as a parent of your porject.

The problem with the above approch is that the all dependencies specified in the POM are directly included in your project whether or not they are required
and you have to exclude unwanted dependencies your self. Instead, You can import the same POM using dependencyManagement, which just delcares versions but not actually imported.
So client proj can declare only the dependencies it wants. 

 An example is dependencyManagement.
 dependencyManagement is not restricted to be used only in parent pom. If it is parent pom, it is just inherited to childs. If it is in child, it is just usedby 
 other dependencies in the same pom like instance variable.
 Ex:
 <dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-framework-bom</artifactId>
				<version>4.3.8.RELEASE</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
	
	<dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId> -- > This will take spring core 4.3.8.RELEASE.
      </dependency>
  </dependencies>

Import scope
"import" is used to retrieve just dependency management information such as versions and excludes from a remote POM file.
Note that import is only valid with in the dependencyManagement tag and that too only for using "pom" type dependenies which must declare a dependencyManagement tag.

It means the artifact declared as import will include all of its dependent libraries to the project that has declared dependencyManagement from the called project's dependencyManagement section. 
It is useful when you have created project to manage the dependencies(usually we call it Bill of Material BOM) pom, whose job is to provide the libraries to 
the project who wish to import as dependency management section. 

Now we know 2 ways of getting dependencies from another POM. 1. importing dependencies section 2.  importing dependencyManagement
  
What is BOM?
It is bill of materials. A POM file whose sole purpose is to provide dependencyManagement (dependencies with their version info) to client projects using it.  
Client projects are free of specifying version numbers, they just declare the dependencies it wants, and all the dependencies client project referred are 
imported with correct version number according to BOM. One good example of why we want this is, take spring. It supports many databases mysql, mariadb and is a 
general purpose framework. So when client project uses a particualr spring version say : 4.3.8 It defines what all versions of these sub frameworks it is 
compatible. So, cliens can happily use them when they want. With out dependencyManagement tag, spring would burst your project with all of its dependencies.

Ex:

BOM:
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>org.springframework</groupId>
  <artifactId>spring-framework-bom</artifactId>
  <version>4.3.8.RELEASE</version>
  <packaging>pom</packaging>
  <name>Spring Framework (Bill of Materials)</name>
  <description>Spring Framework (Bill of Materials)</description>
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aop</artifactId>
        <version>4.3.8.RELEASE</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>4.3.8.RELEASE</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-beans</artifactId>
        <version>4.3.8.RELEASE</version>
      </dependency>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>4.3.8.RELEASE</version>
      </dependency>
......... so many.....
    </dependencies>
  </dependencyManagement>
</project>


Client project:
<project>
  <groupId>com.test</groupId>
  <artifactId>use</artifactId>
  <version>1.0.0</version>
  <packaging>jar</packaging>
 
 <dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework</groupId>
				<artifactId>spring-framework-bom</artifactId>
				<version>4.3.8.RELEASE</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
	
	<dependencies>
      <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId> -- > This will take spring core 4.3.8.RELEASE.
      </dependency>
  </dependencies>
  
</project>

What is advantage of this?
1. Even If there are 10 sub projects in the dependency, client project dev is free of identifying which version of one module is compatible another and declare each version of module in its POM.
2. Cant this be achived by declaring the bom as a parent? Yes, but what if the client proj already has a parent, i.e client project already extends another POM?
3. client project only imports the parent pom. Both client project and the parent project's child share the version in parent.  So just changing the version number
in the parent file will reflect in client and also in its child project.

Parent child projects:
-------------------------
The use of parent projects is to Share dependencies across all the child projects. Also, It declares a specific version of the dependencies,
so that that specific dependency version will be consistent across all its child projects. The advantage of parent child is that, all the preoperties, dependencyManagement, dependencies....etc what not? Every thing is imported to child projects.
To see what are all imported, you can take a look at the effective POM of your pom file. This will show you what are imported from parents.
In eclipse just, Ctrl + Click on the <parent> tag to see parent pom. You can also Ctrl + Click on the <dependency> tag to see dependency's pom. 
There can be only one direct parent for a pom.
C:.
└───parent
    │   pom.xml
    │
    └───child1
        │   pom.xml
        │
        ├───src
        │   ├───main
        │   │   ├───java
        │   │   └───resources

parent pom.xml
------------------
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.cts</groupId>
  <artifactId>projects</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>
</project>

child pom.xml
------------------
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.cts.childs</groupId>
  <artifactId>childs</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  
  <parent>
   <groupId>com.cts</groupId>
  <artifactId>projects</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  </parent>
  
</project>

With this child project inherits all the dependencies defined by parent, and if it wants to override a particular dependency version
child project can redefine it in its pom. Maven will pick the child project defined version only. Ok, looks good, can we exclude a dependency from
parent from being inherited altogether? No, it is not possible. Maybe you could simply not inherit from the parent in that case.


In the above configuration, If u build child or parent, the other project's build will not be triggered automatically.For that, You need
to go for module maven project. 

Maven Multi Module project
--------------------------------
The advantages of using multi module maven project are a lot. Some are listed below:

Using dependency-management, the parent project can control all the sub-modules use the same version of a particular dependency.
By listing modules and building the parent pom, all the sub-modules will be built in the order they are mentioned and there is no 
need to build individual modules. We just need to Do a maven clean install on parent project which will in turn build all the modules.
As all the child projects inherit parent project’s group-id and version, all the modules’ group-id and version will be consistent and can be 
maintained in a single place. 
Ex:

└───parent
    │   pom.xml
    │
    └───child1
        │   pom.xml
        │
        ├───src
        │   ├───main
        │   │   ├───java
        │   │   └───resources

parent: 

<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.vt.sample-multi-module-project</groupId>
    <artifactId>multi-module-parent</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <properties>
        <junit.version>4.11</junit.version>
        <spring.version>4.0.0.RELEASE</spring.version>
        <jackson.version>2.3.2</jackson.version>
    </properties>
     <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>${spring.version}</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>${jackson.version}</version>
            </dependency>
            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>${junit.version}</version>
                <scope>test</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <modules>
        <module>../multi-module-service</module>
        <module>../multi-module-web</module>
    </modules>
</project>

child: 
<project>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>multi-module-service</artifactId>
    <packaging>jar</packaging>
    <parent>
        <groupId>com.vt.multi-module-project</groupId>
        <artifactId>multi-module-parent</artifactId>
        <version>1.0-SNAPSHOT</version>
        <relativePath>../multi-module-parent</relativePath>
    </parent>
    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
    </dependencies>
</project>

Now when we build parent>pom.xml it automatically builds child1 project and finally u get this message:
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO]
[INFO] projects .......................................... SUCCESS [1.036s]
[INFO] childs ............................................ SUCCESS [2.452s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.943s


Maven profiles:
-----------------------

Common maven commands:
--------------------------
How can I tell which profiles are in effect during a build?
mvn help:active-profiles

mvn -version: When you have multiple jdks installed, which java do u expect maven to pick while comiling your classes?
of course, based on the JAVA_HOME set. But, If u want explicitly know from maven which java it is using for compilation, you can say maven -version.
It will also spit out the java verion it is using to compile.
 
mvn help:describe -Dcmd=<lifecycle/build phase> : 
Tells whether the cmd is a lifecycle or goal.
Describes the phases and goals bounded to each phase if the cmd is a lifecycle. 
if the cmd is a phase,  then it lists all other phases in the lifecycle the command belongs to.


mvn -DskipTests clean install -o : works offline.
mvn -Pdev eclipse:eclipse
mvn -help: Shows you all options avaialble.
mvn clean install -X: runs maven in debug mode, You can see how maven picked a configuration..etc.
mvn clean install -lC:\krishna.log
mvn dependency:list: Shows a list of dependencies the current project has.
mvn dependency:tree: Shows a tree of dependencies the current project has.
mvn dependency:analyze : Allows you identify unused dependencies.

mvn help:all-profiles: Shows all available build profiles.
mvn help:describe -Dplugin=<plugin-name> : Describes all the info about the give plugin, what goals it has..etc
Ex: mvn help:describe -Dplugin=gwt
    mvn help:describe -Dplugin=gwt -Dfull=true
In the above code, help is a maven plugin and we are invoking its goals like describe with args.
mvn help:help: This explains you about help plugin itself.
mvn help:describe -Dplugin=help

How can I find out the default phase a Maven goal binds to?
Given the following plugin declaration, How will you identify when that particualr plugin will be invoked?
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<executions>
					<execution>
						<goals>
							<goal>repackage</goal>
						</goals>
					</execution>
				</executions>
			</plugin>

mvn help:describe -DartifactId=maven-compiler-plugin -DgroupId=org.apache.maven.plugins -Dgoal=compile -Ddetail
mvn help:describe -DgroupId=org.springframework.boot -DartifactId=spring-boot-maven-plugin -Dgoal=repackage -Ddetail






