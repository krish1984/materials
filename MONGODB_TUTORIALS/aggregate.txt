
Json rules:
------------------
1. What is an object?
An object is a list of key value pairs seperated by , all together enclosed by {}. In json, anything that is inside a {} is an object. 
Ex: { person: { name: "krishna",age:29 } }. In this case person value is an object, name value is just a value (i.e single atomic value).

2. Diff between key-value pair and object?
Key-value pair: name:krishna, object: {name:krishna}

3. If a key's value is a key-value pair, then it must be enclosed in {}. Normally, a key-value pair not always need to be enclosed in {}, only when used as a value for a key.

Ex: db.records.find( { "dob" : $exists:true )  -- > wrong, the $exists:true must be enclosed in curly brances, bcoz u r using it as a value.
    db.records.find( { "dob" : {$exists:true}} ) --> right.
	
4. An object (takes form of {} ) accepts only key-value pairs not objects directly.

{
_id: {
		{state: "$state"}, -------------> json error! An objeect accepts only key-value pairs, not objects itself.
		{city: "$city" }                  
     }
}

Following is valid:
{
_id: {
		state: "$state", 
		city: "$city"                   
     }
}


5. An array accepts only objects. As u know from point1, an object is any no of key-value pairs enclosed in a {}.

 db.zips.aggregate([ 
	   $group: {_id:"$state"} ,  -----> wrong, an array accepts only objects, but not key value pairs. 
	   $sort : {"_id":1}
	]) 
	
	db.zips.aggregate([ 
	  { $group: {_id:"$state"} } ,  -----> right!
	  { $sort : {"_id":1} }
	]) 
6. A json can never have comma seperated values Ex: {_id: { "$state", "$city" } } is wrong!


Group:
-------------
Working set:

{ "_id" : 1, "item" : "abc", "price" : 10, "quantity" : 2, "date" : ISODate("2014-01-01T08:00:00Z") }
{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "date" : ISODate("2014-02-03T09:00:00Z") }
{ "_id" : 3, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-03T09:05:00Z") }
{ "_id" : 4, "item" : "abc", "price" : 10, "quantity" : 10, "date" : ISODate("2014-02-15T08:00:00Z") }
{ "_id" : 5, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T09:05:00Z") }
{ "_id" : 6, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-15T12:05:10Z") }
{ "_id" : 7, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T14:12:12Z") }

In mongo, the groupby query is written using a "$group" field that has mandatory a "_id" property (Mandatory bcoz its the one that tells, on 
which column(s) the records need to be grouped)  and an optional list of labels each with an aggregate expression. Ex: $min, $max, $first, 
$last, $sum, $avg, $add, $substract or any combination of all of these.

The "_id" property accepts either an atomic value (when ur groupng only single column)  or an object (when ur groupng more column names). 
Note that, the column names u specify in the $group must start with "$".

Ex: 
db.zips.aggregate([ 	
{ $group: {_id:"$state"} } --> tells to group by state
])
SQL equivalent: select state from zips groupby state;

op:
{
    "_id" : "AK"
},
{
    "_id" : "AL"
},
{
    "_id" : "AR"
}

As you can see, unlike in SQL we did't have to add a "$project" key to specify the select columns. The definition of group field u wrote itself 
will be automatically rendered as a part of resultset. i.e Mongo automatically displays the _id column with actual grouped values. 

Group by more fields:

If you want to use more than one column in the (i.e groupby more columns) then, you may tend to directly put them in a {} sepected by comma.
But, you get a json syntax error.Refer to point 6 above.

db.zips.aggregate([ 	
{ $group: {_id: { "$state", "$city" } } --> not allowed, JSON doesnt allow this. Refer to point 6 above.
])

Valid: 
-----
db.zips.aggregate([ 	
{
	$group: {_id: {state: "$state", city: "$city"} }
} 
])

Output: {
    "_id" : {
        "state" : "AK",
        "city" : "WRANGELL"
    }
}
,
{
    "_id" : {
        "state" : "AK",
        "city" : "POINT BAKER"
    }
}
As discussed above, the _id column will be the default column shown in the resultset of a groupby query. By no way, You can get rid of this.

Just like in SQL, the order of the columns you specify in the _id property of $group doesnt matter. The DB will find what column becomes the 
super set and what becomes its subset and so on for all columns specified in the groupby.
In the above example, It groups records by state and taking each state's group/set of records it again performs a group based on city, i.e 
performs the sub grouping as follows:
AP VIJ
AP GNT
UP LKN
UP BNRS
U will only see the distinct values (city)of the lowest subset, with duplicate values(state) of its super set,  with duplicate values of its 
super set...etc.
 
If you also, specify another column that can be even a subgroup of city say for ex: zip_code or _id (which is unique), then even if there r 100 
records in ur actual collection, the result set size also will be 100.

How many no of results can u expect from a groupby query?
It depends on the columns in groupby field. 
If there r  only 2 distinct states in ur collection, no matter there r 1300 records in ur collection the groupby result size is 2.
If there r  2 distinct states and 10 distinct cities in ur collection, no matter there r 1300 records in ur collection the groupby result size is 10.
If u also groupby by some unique property like zip_code or _id, then result size = total colleaction size.

Once grouping of records is done mongo, considers each group in the resultset as a seperate set. i.e u can pick $first value, $last value or $sum, $avg records from each group.

How mongo stores & retrieves the records from the disk ?
-------------------------------------------------------
Before  u understand groupby, we need to see how data is stored in mongo. Mongo stores, records in the next memory localtion (linkedlist) as 
and when records are inserted into it. If you insert the following records onebyone, they will be inserted oneafter other in the 
next address on the disk.

{ "_id" : 1, "item" : "abc", "price" : 10, "quantity" : 2, "date" : ISODate("2014-01-01T08:00:00Z") }
{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "date" : ISODate("2014-02-03T09:00:00Z") }
{ "_id" : 3, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-03T09:05:00Z") }
{ "_id" : 4, "item" : "abc", "price" : 10, "quantity" : 10, "date" : ISODate("2014-02-15T08:00:00Z") }
{ "_id" : 5, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T09:05:00Z") }
{ "_id" : 6, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-15T12:05:10Z") }
{ "_id" : 7, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T14:12:12Z") }


When u query the DB using db.sales.find() with no sorting, mongo returns the records in the same order as it encounters those on the disk.

To prove this, lets delete the record with _id=3, and reinsert it again. Now run the same query. This time the record is added to the next 
bucket on the disk.

How groupby internally works in mongo?
-------------------------------------
Eventhough mongo aggregate works in pipeline mode, You can say, the Mongo grouping stage itself works as a pipe line operation. i.e grouping 
has multiple stages.
Following are the steps in grouping stage:
1. scan through the disk and collect the record into the groups, in the same order as they are encountered on the disk and collect/group them based on the group keys
2. The result is that you see a resultset whose size is equal to the collection size, that looks like(not actually sorted) sorted records 
based on group keys.
Ex: The above working set becomes like following when u say "groupby by item":
{ "_id" : 1, "item" : "abc", "price" : 10, "quantity" : 2, "date" : ISODate("2014-01-01T08:00:00Z") }
{ "_id" : 4, "item" : "abc", "price" : 10, "quantity" : 10, "date" : ISODate("2014-02-15T08:00:00Z") }
{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "date" : ISODate("2014-02-03T09:00:00Z") }
{ "_id" : 3, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-03T09:05:00Z") }
{ "_id" : 5, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T09:05:00Z") }
{ "_id" : 6, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-15T12:05:10Z") }
{ "_id" : 7, "item" : "xyz", "price" : 5, "quantity" : 10, "date" : ISODate("2014-02-15T14:12:12Z") }

3. Now get the 1 record in each such group. If there are any aggregate operations specified, perform those operations on each group and 
prepare the final row for that group. This is a 2 step process:
step1 output:
{ "_id" : 1, "item" : "abc", "price" : 10, "quantity" : 2, "date" : ISODate("2014-01-01T08:00:00Z") }
{ "_id" : 2, "item" : "jkl", "price" : 20, "quantity" : 1, "date" : ISODate("2014-02-03T09:00:00Z") }
{ "_id" : 3, "item" : "xyz", "price" : 5, "quantity" : 5, "date" : ISODate("2014-02-03T09:05:00Z") }

step2 output (final output): 
{ "item" : "abc",  "dateDiff" : 2 }
{ "item" : "jkl", "dateDiff" : 3 }
{ "item" : "xyz", "date" : 2 }

5. Display the results to user.


When grouping, mongo just scans through the disk from location 0--n, so it would get the same order of records as they were inserted and 
performs its grouping algorithm. How to prove this:

db.sales.aggregate(
   [  { $match: {"item": "xyz"}}
     {
       $group:
         {
           _id: "$item",
           firstSalesDate: { $first: "$date" }  ---> o/p will be 3rd records date: "2014-02-03T09:05:00Z"
         }
     }
   ]
)

Delete this 3rd record and re insert it again and run the above query, this time output will be 5th record's date : 2014-02-15T09:05:00Z.

So,You can take it for granted that, in each group that mongo has built, the record that was inserted 1st will be the 1st one in the group.